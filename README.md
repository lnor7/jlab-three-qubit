# Three-qubit QIP

## Setup

These scripts only work on the Athena computer by the QIP station, unless you have SSH access set up on the computer for the Bruker. Before doing anything else, you need to run NMRStartup.m (or alternately, just do "load calib". The setup is, in other words, the same as for 2-qubit QIP. 

## Sample flow of a pulse program

Let's step through everything that the pulse program script toffolipp.m is doing. This script is roughly equivalent to the kinds of pulse programs that people make in the 2-qubit case. Everything that you actually have to do is in steps 1 and 2 but I'm talking through the whole code path so that it'll be easy to change anything that needs changing later on.

1. (before toffolipp.m): set phref. Phref has three rows and two columns. Each row is one of the nuclei, H, C1, and C2 in order. The first column is for the zero-th order phase calibration (the basic phase calibration that you do in two-qubit QIP). The second column is for the first order phase calibration. This one is a pain to set, but essentially you add a second phase calibration of the form exp(i\* phc1 \* df). It's first order because it goes as the frequency. In practice, I usually ended up just setting phref to be [0 0; 0 0; 0 0] and then applying the phase calibration after taking data. You can see some messy code in mycalib.m that can be used to find phref. Basically I picked a reference peak and used that to set the zero-th order phase calibration. Then I picked another peak and used that to set the first order phase calibration. The phases of the peaks are kind of finnicky so when I was doing this for my poster I usually tried all three remaining peaks for the first order calibration and then optimized.
2. Within toffolipp.m: define pulses, phases, and delays. Rather than being two-row matrices, they are now three-row matrices, with the rows being H, C1, C2 in order. (There's a funny thing in the way this one got defined: non-integer multiples of pw were making the spectrometer unhappy, so in order to get pi/4 pulses I set pw to be half of what it actually was and then added factors of two everywhere else.) Once everything is set, NMRRunPulseProg.m gets called.
3. NMRRunPulseProg.m is where most things actually happen. First, it calls NMRSetCalibPhases which stores phref in a calib file that can be read across scripts. Then it calculates some two-qubit permutation matrices for temporal averaging, which aren't relevant here. It goes without saying that three-qubit temporal averaging isn't implemented yet. I do know how to do it in theory, see the writeup for more detail. Eventually NMRRunPulseProg gets to the important bits, around line 212. Here is where the actual pulse acquisiton happens, once for each selected nucleus. Everything is the same for every nucleus, so let's just consider hydrogen, between line 212 and line 258.
4. The first thing that happens for pulse acquisition is setting the pulse program, using write_pp.m, which translates from our matlab arrays into the Bruker pulse program language. It writes a Bruker-formatted pulse program to the local file juniorlabpp. If you're going to be working with this, you'll want to teach yourself the Bruker syntax. One thing to note here is that the carbon pulses are using the shaped pulse syntax: p11:sp1:f2 and p12:sp2:f2. p11 and p12 are the stored pulse widths for shaped pulses and sp1 and sp2 are the stored shaped pulses. these live in the param files lnorTCE-13C-shaped1 and lnorTCE-13C-shaped2 on the Bruker machine.
5. After the pulse program is converted into Bruker format, it gets sent over telnet to the Bruker machine. nmrx.c handles all of this. (NOTE: nmrx.c is completely content-agnostic. it just sends files over the connection. you shouldn't need to change it for three-qubit unless something unrelated breaks.) An additional series of nmrx commands also sets the Bruker param file in NMRLoadParam based on the nucleus and updates the pulse width for hydrogen. Finally, the pulse program is set to juniorlabpp, the name of the file that we sent over telnet.
6. Once the pulse program is finished, you also need to get the data back from the bruker, which happens in b2sdatNoPlot. There's a lot that happens here. You can get parameters from nmrx with 'getparm [datatype] [parametername]' but it will be very upset if you get the datatype wrong. The command 'getdat' in nmrx has been defined to read in the entire FID and is very convenient. After getting the FID, the FFT then happens, in the same file. Phase corrections can also happen here, using the first two rows of phref. The function dophase is another good example of how first order phase corrections work. After this, it returns an object with the data, intermediate steps, and various parameters. I didn't change this much in the end but went through a few iterations where I changed a lot more.
7. Play a fun sound based on the FID. 
8. Integrals. From here on, we aren't doing anything with the Bruker apparatus, which means that we can adjust steps here without taking any more data. First step is to load the parameters relevant to integration from calib.mat and then loop over the different nuclei. Things are the same for each nucleus so we'll just focus on hydrogen. All the k-indexing and summing here is only relevant when you're doing state averaging. Pretty much everything is contained in one call to do_integral.
9. Within the function things are pretty straightforward. The phase correction happens again inside of do_integral. I think I did this so I could adjust the phase correction without taking more data. After corrections it's just a trapezoidal integration of the spectrum in the selected frequency region. As the documentation notes, this is somewhat questionable because we know the peaks should be lorentzians.
10. Integrals are returned and put into the final datafile, which is saved as a spect object.
11. NMRplotSpectra generates a plot, again with its own phase correction.

